// @generated
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pose {
    #[prost(double, tag="1")]
    pub lat_deg: f64,
    #[prost(double, tag="2")]
    pub lon_deg: f64,
    #[prost(float, tag="3")]
    pub heading_deg: f32,
    /// Position covariance \[m^2\] defined relative to a tangential plane
    ///   through the reported position. The components are East, North, and
    ///   Up (ENU), in row-major order.
    #[prost(float, repeated, tag="4")]
    pub position_covariance: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, optional, tag="5")]
    pub heading_error_deg: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spokes {
    /// total number of spokes in one complete scan
    #[prost(uint32, tag="1")]
    pub num_spoke: u32,
    #[prost(uint32, tag="2")]
    pub first_spoke_index: u32,
    #[prost(float, tag="3")]
    pub range_m: f32,
    /// contains multiple spokes. each spoke is a byte
    #[prost(bytes="vec", repeated, tag="4")]
    pub spokes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Info {
    #[prost(message, optional, tag="1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="9")]
    pub ttag_steady_ns: u64,
    #[prost(enumeration="State", tag="2")]
    pub state: i32,
    #[prost(int32, tag="3")]
    pub gain: i32,
    #[prost(int32, tag="4")]
    pub rain: i32,
    #[prost(int32, tag="5")]
    pub sea: i32,
    #[prost(int32, tag="6")]
    pub range: i32,
    #[prost(int32, tag="7")]
    pub scan_speed: i32,
    #[prost(message, optional, tag="8")]
    pub spokes: ::core::option::Option<Spokes>,
    #[prost(message, optional, tag="10")]
    pub pose: ::core::option::Option<Pose>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(enumeration="CommandType", tag="1")]
    pub command: i32,
    #[prost(int64, tag="2")]
    pub value: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    Off = 0,
    Standby = 1,
    WarmingUp = 2,
    TimedIdle = 3,
    Stopping = 4,
    SpinningDown = 5,
    Starting = 6,
    SpinningUp = 7,
    Transmit = 8,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Off => "STATE_OFF",
            Self::Standby => "STATE_STANDBY",
            Self::WarmingUp => "STATE_WARMING_UP",
            Self::TimedIdle => "STATE_TIMED_IDLE",
            Self::Stopping => "STATE_STOPPING",
            Self::SpinningDown => "STATE_SPINNING_DOWN",
            Self::Starting => "STATE_STARTING",
            Self::SpinningUp => "STATE_SPINNING_UP",
            Self::Transmit => "STATE_TRANSMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_OFF" => Some(Self::Off),
            "STATE_STANDBY" => Some(Self::Standby),
            "STATE_WARMING_UP" => Some(Self::WarmingUp),
            "STATE_TIMED_IDLE" => Some(Self::TimedIdle),
            "STATE_STOPPING" => Some(Self::Stopping),
            "STATE_SPINNING_DOWN" => Some(Self::SpinningDown),
            "STATE_STARTING" => Some(Self::Starting),
            "STATE_SPINNING_UP" => Some(Self::SpinningUp),
            "STATE_TRANSMIT" => Some(Self::Transmit),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommandType {
    /// value ignored
    CommandNone = 0,
    /// value ignored
    CommandTurnOn = 1,
    /// value ignored
    CommandTurnOff = 2,
    /// value is range in meters
    CommandSetRange = 3,
    CommandSetGain = 4,
}
impl CommandType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CommandNone => "COMMAND_NONE",
            Self::CommandTurnOn => "COMMAND_TURN_ON",
            Self::CommandTurnOff => "COMMAND_TURN_OFF",
            Self::CommandSetRange => "COMMAND_SET_RANGE",
            Self::CommandSetGain => "COMMAND_SET_GAIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMAND_NONE" => Some(Self::CommandNone),
            "COMMAND_TURN_ON" => Some(Self::CommandTurnOn),
            "COMMAND_TURN_OFF" => Some(Self::CommandTurnOff),
            "COMMAND_SET_RANGE" => Some(Self::CommandSetRange),
            "COMMAND_SET_GAIN" => Some(Self::CommandSetGain),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
